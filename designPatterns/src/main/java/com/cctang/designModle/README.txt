
==================================单例模式（Singleton）=============================================
单例模式有 3 个特点：
    单例类只有一个实例对象；
    该单例对象必须由单例类自行创建；
    单例类对外提供一个访问该单例的全局访问点。
实现单利模式的原则和过程：
    1.单例模式：确保一个类只有一个实例，自行实例化并向系统提供这个实例
    2.单例模式分类：饿单例模式（类加载时实例化一个对象给自己的引用），懒单例模式（调用取得实例的方法如getInstance时才会实例化对象）（java中饿单例模式性能优于懒单例模式，c++中一般使用懒单例模式）
    3.单例模式要素：
        a.私有构造方法
        b.私有静态引用指向自己实例
        c.以自己实例为返回值的公有静态方法

使用场景：数据库连接池的设计、多线程的线程池的设计、网站的计数器、Web应用的配置对象的读取

类加载顺序
类加载(classLoader)机制一般遵从下面的加载顺序

如果类还没有被加载：

先执行父类的静态代码块和静态变量初始化，静态代码块和静态变量的执行顺序跟代码中出现的顺序有关。
执行子类的静态代码块和静态变量初始化。
执行父类的实例变量初始化
执行父类的构造函数
执行子类的实例变量初始化
执行子类的构造函数
同时，加载类的过程是线程私有的，别的线程无法进入。

如果类已经被加载：

静态代码块和静态变量不在重复执行，再创建类对象时，只执行与实例相关的变量初始化和构造方法。


懒汉和饿汉
在程序编写上，一般将单例模式分为两种，分别是饿汉式和懒汉式，

饿汉式：在类加载时就完成了初始化，所以类加载比较慢，但获取对象的速度快。
        优点
            1.线程安全
            2.在类加载的同时已经创建好一个静态对象，调用时反应速度快
        缺点
            资源效率不高，可能getInstance()永远不会执行到，但执行该类的其他静态方法或者加载了该类（class.forName)，那么这个实例仍然初始化

懒汉式：在类加载时不初始化，等到第一次被使用时才初始化。
        优点：
            避免了饿汉式的那种在没有用到的情况下创建事例，资源利用率高，不执行getInstance()就不会被实例，可以执行该类的其他静态方法。
        缺点：
            懒汉式在单个线程中没有问题，但多个线程同事访问的时候就可能同事创建多个实例，而且这多个实例不是同一个对象，
            虽然后面创建的实例会覆盖先创建的实例，但是还是会存在拿到不同对象的情况。解决这个问题的办法就是加锁synchonized，第一次加载时不够快，多线程使用不必要的同步开销大。

双重检测
        优点
            资源利用率高，不执行getInstance()就不被实例，可以执行该类其他静态方法
        缺点
            第一次加载时反应不快，由于java内存模型一些原因偶尔失败

静态内部类
        优点
            资源利用率高，不执行getInstance()不被实例，可以执行该类其他静态方法
        缺点
            第一次加载时反应不够快

总结：
    一般采用饿汉式，若对资源十分在意可以采用静态内部类，不建议采用懒汉式及双重检测


================================建造者模式( Builder )=======================================
成员结构：

产品（Product）：它是包含了多个组成部分的复杂的对象，由具体的创造者完成另加后由指挥者组装而成
抽象建造者（Builder）：它是一个包含创建产品各个子部件的方法接口，又具体建造者继承，通常还需要包含一个返回复杂产品的方法
具体建造者(Concrete Builder）：实现Builder接口，完成各个零部件的具体化的创建方法
指挥者（Director）：负责调用建造者对象中的部件构造和装配的方法，从而完成复杂对象的创建

定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。

它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。

优点：

封装性好，构建和表示分离。
扩展性好，各个具体的建造者相互独立，有利于系统的解耦。
客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。
建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。



=====================================原型模式(Prototype)====================================================================
一.定义

原型模式：原型模式用于创建重复的对象，实现对象的拷贝。这种模式类似于创建型模式，提供了创建对象的最佳模式。

这种模式存在的应用场景在于，能够复制当前对象，实现对象数据的克隆。比如：如果一个对象的数据需要经过较高代价的数据库操作，采用原型模式能够较好的缓存当前对象，减少数据库的访问量。

二.使用场景

思想：用实例对象，指导对象的创建工作.

应用：1.一个复杂的对象，包含多种数据和结构，层次较深时，适用与原型模式（当需要创建一个与复杂对象部分数据相同的对象）

          2.当复杂对象需要独立于系统运行，而不破坏本系统中的结构

实例场景：1.一个楼盘有名称，地址和施工队三个成员变量。施工队有名称，人数和包工头。包工头有名称和年龄。现在要建设一个隔壁的楼盘，还是由这个施工队进行建设的，只是地址不同。

如果重新创建，过程较为复杂，费时费力，采取原型模式可以快速构建一个新的楼盘

                 2.系统中已经有一架飞机，飞机有名称和型号和厂商。厂商有名称，地址和负责人。负责人有姓名和年龄。现在要一家相同的飞机由不同的负责人进行指导生产的，如何快速创建这样的对象。

原型模式的优点：
A. Java 自带的原型模式基于内存二进制流的复制，在性能上比直接 new 一个对象更加优良。
B. 可以使用深克隆方式保存对象的状态，使用原型模式将对象复制一份，并将其状态保存起来，简化了创建对象的过程，以便在需要的时候使用（例如恢复到历史某一状态），可辅助实现撤销操作。

原型模式的缺点：
A.需要为每一个类都配置一个 clone 方法
B.clone 方法位于类的内部，当对已有类进行改造的时候，需要修改代码，违背了开闭原则。
C.当实现深克隆时，需要编写较为复杂的代码，而且当对象之间存在多重嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来会比较麻烦。因此，深克隆、浅克隆需要运用得当。

三. 模式的实现
原型模式的克隆分为浅克隆和深克隆。
浅克隆：创建一个新对象，新对象的属性和原来对象完全相同，对于非基本类型属性，仍指向原有属性所指向的对象的内存地址。
深克隆：创建一个新对象，属性中引用的其他对象也会被克隆，不再指向原有对象地址。

=======================================工厂模式====================================================================
定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。

工厂模式有 3 种不同的实现方式，分别是简单工厂模式、工厂方法模式和抽象工厂模式。

“简单工厂模式”是只要一个工厂类就可以完成。


------------------------------------简单工厂类--------------------------------
Factory：工厂类，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。
IProduct：抽象产品类，简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。
Product：具体产品类，是简单工厂模式的创建目标。


“简单工厂模式”的优点和缺点
优点：
A.工厂类包含必要的逻辑判断，可以决定在什么时候创建哪一个产品的实例。
  客户端可以免除直接创建产品对象的职责，很方便的创建出相应的产品。工厂和产品的职责区分明确。
B.客户端无需知道所创建具体产品的类名，只需知道参数即可。
C.也可以引入配置文件，在不修改客户端代码的情况下更换和添加新的具体产品类。

缺点：
A.简单工厂模式的工厂类单一，负责所有产品的创建，职责过重，一旦异常，整个系统将受影响。
  且工厂类代码会非常臃肿，违背高聚合原则。
B.使用简单工厂模式会增加系统中类的个数（引入新的工厂类），增加系统的复杂度和理解难度
C.系统扩展困难，一旦增加新产品不得不修改工厂逻辑，在产品类型较多时，可能造成逻辑过于复杂
D.简单工厂模式使用了 static 工厂方法，造成工厂角色无法形成基于继承的等级结构。

应用场景
对于产品种类相对较少的情况，考虑使用简单工厂模式。使用简单工厂模式的客户端只需要传入工厂类的参数，不需要关心如何创建对象的逻辑，可以很方便地创建所需产品。

---------------------------------工厂方法模式---------------------------------------------
 模式的结构
工厂方法模式的主要角色如下。
抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

“工厂方法模式”是对简单工厂模式的进一步抽象化，其好处是可以使系统在不修改原来代码的情况下引进新的产品，即满足开闭原则。

优点：
A.用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程。
B.灵活性增强，对于新产品的创建，只需多写一个相应的工厂类。
C.典型的解耦框架。高层模块只需要知道产品的抽象类，无须关心其他实现类，
  满足迪米特法则、依赖倒置原则和里氏替换原则。

缺点：
A.类的个数容易过多，增加复杂度
B.增加了系统的抽象性和理解难度
C.抽象产品只能生产一种产品，此弊端可使用抽象工厂模式解决。

应用场景：
A.客户只知道创建产品的工厂名，而不知道具体的产品名。如 TCL 电视工厂、海信电视工厂等。
B.创建对象的任务由多个具体子工厂中的某一个完成，而抽象工厂只提供创建产品的接口。
C.客户不关心创建产品的细节，只关心产品的品牌

模式组成

组成（角色）	                      关系	                                作用
抽象产品（Product）	          具体产品的父类	                       描述具体产品的公共接口
具体产品（Concrete Product）	  抽象产品的子类,工厂类创建的目标类	   描述生产的具体产品
抽象工厂（Creator）	          具体工厂的父类	                       描述具体工厂的公共接口
具体工厂（Concrete Creator）	  抽象工厂的子类,被外界调用	           描述具体工厂；实现FactoryMethod工厂方法创建产品的实例

 使用步骤

步骤1： 创建抽象工厂类，定义具体工厂的公共接口；
步骤2： 创建抽象产品类 ，定义具体产品的公共接口；
步骤3： 创建具体产品类（继承抽象产品类） & 定义生产的具体产品；
步骤4：创建具体工厂类（继承抽象工厂类），定义创建对应具体产品实例的方法；
步骤5：外界通过调用具体工厂类的方法，从而创建不同具体产品类的实例